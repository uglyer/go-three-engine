package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

//go:embed webgpu.h
var webgpuCode string

//go:embed wgpu.h
var wgpuCode string

type Pair struct {
	Enum  string
	Value string
}

type TypedefEnum struct {
	Name  string
	Enums []Pair
}

type Enums []TypedefEnum

func (e Enums) Add(t string, enum string, value string) Enums {
	found := false
	for i, v := range e {
		if v.Name == t {
			found = true
			v.Enums = append(v.Enums, Pair{
				Enum:  enum,
				Value: value,
			})
			e[i] = v
		}
	}

	if !found {
		e = append(e, TypedefEnum{
			Name: t,
			Enums: []Pair{{
				Enum:  enum,
				Value: value,
			}},
		})
	}
	return e
}

func main() {
	var enums = Enums{}
	skipTypes := map[string]bool{
		"SType":       true,
		"NativeSType": true,
	}
	mergeTypes := map[string]string{
		"NativeFeature": "FeatureName",
	}
	repalceString := map[string]string{
		"PowerPreference_Undefined": "default",
	}
	re := regexp.MustCompile(`(?m)^\s*(\w+)\s*=\s*(\w+),?$`)
	matches := re.FindAllStringSubmatch(webgpuCode, -1)
	for _, match := range matches {

		key := match[1]
		value := match[2]
		if !strings.HasPrefix(key, "WGPU") {
			continue
		}
		key = strings.TrimPrefix(match[1], "WGPU")
		index := strings.Index(key, "_")
		if index < 0 {
			continue
		}
		typ := key[:index]
		if _, ok := skipTypes[typ]; ok {
			continue
		}
		inTyp, ok := mergeTypes[typ]
		if ok {
			enums = enums.Add(inTyp, key, value)
		} else {
			enums = enums.Add(typ, key, value)
		}
		//fmt.Println(typ, key, value)
	}
	sort.SliceStable(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})

	w := &bytes.Buffer{}

	fmt.Fprintf(w, "// Code generated by cmd/gen_enums. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", "wgpu")
	fmt.Fprintf(w, "import \"fmt\"\n\n")
	re2 := regexp.MustCompile(`[A-Z][^A-Z]*|\dD`)
	for _, e := range enums {
		sort.SliceStable(e.Enums, func(i, j int) bool {
			return e.Enums[i].Value < e.Enums[j].Value
		})

		fmt.Fprintf(w, "type %s uint32\n\n", e.Name)
		fmt.Fprintf(w, "const (")
		for _, v := range e.Enums {
			enum := v.Enum
			value := v.Value
			fmt.Fprintf(w, "    %s %s = %s\n", enum, e.Name, value)
		}
		fmt.Fprintf(w, ")")

		fmt.Fprint(w, "\n")

		fmt.Fprintf(w, "func (v %s) String() string {\n", e.Name)
		fmt.Fprintf(w, "switch v {\n")
		for _, v := range e.Enums {
			fmt.Fprintf(w, "case %s:\n", v.Enum)
			if kebab, ok := repalceString[v.Enum]; ok {
				fmt.Fprintf(w, "return \"%s\"\n", kebab)
				continue
			}
			words := re2.FindAllString(strings.TrimPrefix(v.Enum, e.Name+"_"), -1)
			kebab := strings.ToLower(strings.Join(words, "-"))
			fmt.Fprintf(w, "return \"%s\"\n", kebab)
		}
		if e.Name == "ErrorType" {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprintf(w, "return \"unknown\"\n")
		} else {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprintf(w, "return \"\"\n")
		}
		fmt.Fprintf(w, "}\n")
		fmt.Fprintf(w, "}\n")

		fmt.Fprintf(w, "func StringTo%s(str string) %s {\n", e.Name, e.Name)
		fmt.Fprintf(w, "switch str {\n")
		for _, v := range e.Enums {
			kebab, ok := repalceString[v.Enum]
			if !ok {
				words := re2.FindAllString(strings.TrimPrefix(v.Enum, e.Name+"_"), -1)
				kebab = strings.ToLower(strings.Join(words, "-"))
			}
			fmt.Fprintf(w, "case \"%s\":\n", kebab)
			fmt.Fprintf(w, "return %s\n", v.Enum)
		}
		if e.Name == "ErrorType" {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprintf(w, "return ErrorType_Unknown\n")
		} else {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprint(w, "panic(fmt.Sprintf(\"%s convert to "+e.Name+" error\", str))\n")
		}
		fmt.Fprintf(w, "}\n")
		fmt.Fprintf(w, "}\n")
	}
	out, err := os.Create("./engine/renderer/wgpu/enums.go")
	if err != nil {
		panic(err)
	}
	out.Write(w.Bytes())
}
